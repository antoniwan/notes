---
interface Props {
  id: string;
  datasets: Array<{
    label: string;
    data: Array<{ x: number; y: number }>;
    backgroundColor?: string;
    borderColor?: string;
    pointRadius?: number;
  }>;
  title?: string;
  xAxisLabel?: string;
  yAxisLabel?: string;
  showRegressionLine?: boolean;
}

const { id, datasets, title, xAxisLabel, yAxisLabel, showRegressionLine = false } = Astro.props;

// Serialize data for script - ensure it's JSON-serializable
const chartData = JSON.parse(
  JSON.stringify({
    datasets: datasets.map((ds) => ({
      label: ds.label || '',
      data: ds.data || [],
      backgroundColor: ds.backgroundColor || 'rgba(59, 130, 246, 0.6)',
      borderColor: ds.borderColor || 'rgb(59, 130, 246)',
      pointRadius: ds.pointRadius,
    })),
    xAxisLabel: xAxisLabel || '',
    yAxisLabel: yAxisLabel || '',
    showRegressionLine: Boolean(showRegressionLine),
  }),
);
const isDev = import.meta.env.DEV;
---

<div class="mb-6">
  {
    title && (
      <h3 class="mb-4 text-base font-semibold text-[rgb(var(--color-text))] md:text-lg">{title}</h3>
    )
  }
  <div class="relative h-64 w-full md:h-80" id={`chart-container-${id}`} style="min-height: 256px;">
    <!-- Loading State -->
    <div
      id={`chart-loading-${id}`}
      class="absolute inset-0 flex flex-col items-center justify-center rounded-lg border border-[rgb(var(--color-border))] bg-[rgb(var(--color-bg-alt))]"
    >
      <div class="flex flex-col items-center space-y-3">
        <div class="relative">
          <div
            class="h-8 w-8 animate-spin rounded-full border-4 border-[rgb(var(--color-border))] border-t-[rgb(var(--color-accent))]"
          >
          </div>
        </div>
        <p class="text-sm text-[rgb(var(--color-text-muted))]">Calculating data...</p>
      </div>
    </div>
    <canvas id={id} style="display: block; max-width: 100%; height: 100%;"></canvas>
  </div>
</div>

<script define:vars={{ id, chartData, isDev }} is:inline>
  async function initChart() {
    try {
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        await new Promise((resolve) => {
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', resolve, { once: true });
          } else {
            resolve(null);
          }
        });
      }

      // Additional small delay to ensure canvas is rendered
      await new Promise((resolve) => setTimeout(resolve, 100));

      // Load Chart.js from CDN
      if (typeof window.Chart === 'undefined') {
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }

      const Chart = window.Chart;
      // Register components if registerables exists, otherwise Chart.js from CDN already has everything registered
      if (Chart.registerables && Array.isArray(Chart.registerables)) {
        Chart.register(...Chart.registerables);
      }

      const container = document.getElementById(`chart-container-${id}`);
      const canvas = document.getElementById(id);

      if (!canvas || !container) {
        console.error(`Chart elements not found for id "${id}"`);
        if (container) {
          container.style.display = 'none';
        }
        return;
      }

      // Destroy existing chart before re-initializing
      if (canvas.chart) {
        canvas.chart.destroy();
        canvas.chart = null;
      }

      if (!chartData || !chartData.datasets) {
        if (isDev && typeof console !== 'undefined') {
          console.error('Chart data not found or invalid:', chartData);
        }
        container.style.display = 'none';
        return;
      }

      const { datasets, xAxisLabel, yAxisLabel, showRegressionLine } = chartData;

      if (!datasets || !Array.isArray(datasets) || datasets.length === 0) {
        if (isDev && typeof console !== 'undefined') {
          console.warn('Chart datasets are empty or invalid');
        }
        container.style.display = 'none';
        return;
      }

      // Check if datasets have valid data
      const hasValidData = datasets.some((ds) => {
        if (!Array.isArray(ds.data) || ds.data.length === 0) return false;
        // For scatter charts, check that data points have valid x and y values
        return ds.data.some((point) => {
          if (typeof point === 'object' && point !== null) {
            return (
              typeof point.x === 'number' &&
              typeof point.y === 'number' &&
              !isNaN(point.x) &&
              !isNaN(point.y)
            );
          }
          return false;
        });
      });

      if (!hasValidData) {
        if (isDev && typeof console !== 'undefined') {
          console.warn('Chart datasets contain no valid data');
        }
        container.style.display = 'none';
        return;
      }

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        if (isDev && typeof console !== 'undefined') {
          console.error('Could not get 2d context from canvas');
        }
        container.style.display = 'none';
        return;
      }

      // Get theme based on light/dark mode
      const isDark = document.documentElement.classList.contains('dark');
      const chartTheme = {
        text: isDark ? 'rgb(255, 255, 255)' : 'rgb(17, 24, 39)',
        textMuted: isDark ? 'rgb(200, 210, 220)' : 'rgb(107, 114, 128)',
        border: isDark ? 'rgba(148, 163, 184, 0.3)' : 'rgb(209, 213, 219)',
        bgAlt: isDark ? 'rgb(20, 30, 50)' : 'rgb(249, 250, 251)',
      };

      // Dataset color palette - brighter in dark mode for better visibility
      const datasetColors = isDark
        ? [
            { border: 'rgba(96, 165, 250, 0.9)', background: 'rgba(96, 165, 250, 0.5)' }, // Blue
            { border: 'rgba(248, 113, 113, 0.9)', background: 'rgba(248, 113, 113, 0.5)' }, // Red
            { border: 'rgba(74, 222, 128, 0.9)', background: 'rgba(74, 222, 128, 0.5)' }, // Green
            { border: 'rgba(251, 191, 36, 0.9)', background: 'rgba(251, 191, 36, 0.5)' }, // Amber
            { border: 'rgba(167, 139, 250, 0.9)', background: 'rgba(167, 139, 250, 0.5)' }, // Purple
            { border: 'rgba(244, 114, 182, 0.9)', background: 'rgba(244, 114, 182, 0.5)' }, // Pink
          ]
        : [
            { border: 'rgba(59, 130, 246, 0.7)', background: 'rgba(59, 130, 246, 0.4)' }, // Blue
            { border: 'rgba(220, 38, 38, 0.7)', background: 'rgba(220, 38, 38, 0.4)' }, // Red
            { border: 'rgba(34, 197, 94, 0.7)', background: 'rgba(34, 197, 94, 0.4)' }, // Green
            { border: 'rgba(245, 158, 11, 0.7)', background: 'rgba(245, 158, 11, 0.4)' }, // Amber
            { border: 'rgba(147, 51, 234, 0.7)', background: 'rgba(147, 51, 234, 0.4)' }, // Purple
            { border: 'rgba(236, 72, 153, 0.7)', background: 'rgba(236, 72, 153, 0.4)' }, // Pink
          ];

      // Calculate regression line if requested
      let regressionDatasets = [...datasets];
      if (showRegressionLine && datasets.length > 0 && datasets[0].data.length > 0) {
        const points = datasets[0].data.filter(
          (p) => typeof p.x === 'number' && typeof p.y === 'number' && !isNaN(p.x) && !isNaN(p.y),
        );

        if (points.length >= 2) {
          const xValues = points.map((p) => p.x);
          const yValues = points.map((p) => p.y);

          // Simple linear regression
          const n = points.length;
          const sumX = xValues.reduce((a, b) => a + b, 0);
          const sumY = yValues.reduce((a, b) => a + b, 0);
          const sumXY = points.reduce((sum, p) => sum + p.x * p.y, 0);
          const sumXX = xValues.reduce((sum, x) => sum + x * x, 0);

          const denominator = n * sumXX - sumX * sumX;
          if (denominator !== 0 && !isNaN(denominator)) {
            const slope = (n * sumXY - sumX * sumY) / denominator;
            const intercept = (sumY - slope * sumX) / n;

            if (!isNaN(slope) && !isNaN(intercept)) {
              const minX = Math.min(...xValues);
              const maxX = Math.max(...xValues);
              const regressionLine = [
                { x: minX, y: slope * minX + intercept },
                { x: maxX, y: slope * maxX + intercept },
              ];

              regressionDatasets.push({
                label: 'Regression Line',
                data: regressionLine,
                borderColor: 'rgba(220, 38, 38, 0.8)', // Red
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 2,
                borderDash: [5, 5],
              });
            }
          }
        }
      }

      // Apply consistent colors to datasets
      const processedDatasets = regressionDatasets.map((ds, index) => {
        // Special handling for regression line
        if (ds.label === 'Regression Line') {
          return {
            ...ds,
            borderColor: isDark ? 'rgba(248, 113, 113, 0.9)' : 'rgba(220, 38, 38, 0.8)', // Red
            backgroundColor: 'transparent',
            borderWidth: ds.borderWidth ?? 2,
            pointRadius: 0,
          };
        }

        // Apply theme colors to regular datasets
        const colorIndex = index % datasetColors.length;
        const themeColor = datasetColors[colorIndex];
        const themed = {
          ...ds,
          borderColor: themeColor.border,
          backgroundColor: themeColor.background,
          borderWidth: ds.borderWidth ?? 2,
        };
        // Set default point radius for scatter plots
        if (themed.pointRadius === undefined) {
          themed.pointRadius = 4;
        }
        return themed;
      });

      const chart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: processedDatasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: datasets.length > 1 || showRegressionLine,
              position: 'top',
              labels: {
                color: chartTheme.text,
                usePointStyle: true,
                padding: 15,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 12 },
              },
            },
            tooltip: {
              backgroundColor: chartTheme.bgAlt,
              titleColor: chartTheme.text,
              bodyColor: chartTheme.text,
              borderColor: chartTheme.border,
              borderWidth: 1,
              padding: 12,
              titleFont: { family: 'Open Sans, system-ui, sans-serif', size: 13, weight: '600' },
              bodyFont: { family: 'Open Sans, system-ui, sans-serif', size: 12 },
              cornerRadius: 6,
              callbacks: {
                label: function (context) {
                  return `${context.dataset.label}: (${context.parsed.x.toFixed(2)}, ${context.parsed.y.toFixed(2)})`;
                },
              },
            },
          },
          scales: {
            x: {
              ticks: {
                color: chartTheme.textMuted,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 11 },
              },
              grid: {
                color: chartTheme.border,
                drawBorder: true,
                borderColor: chartTheme.border,
              },
              title: {
                display: !!xAxisLabel,
                text: xAxisLabel,
                color: chartTheme.textMuted,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 12, weight: '500' },
                padding: { top: 10, bottom: 0 },
              },
            },
            y: {
              beginAtZero: false,
              ticks: {
                color: chartTheme.textMuted,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 11 },
              },
              grid: {
                color: chartTheme.border,
                drawBorder: true,
                borderColor: chartTheme.border,
              },
              title: {
                display: !!yAxisLabel,
                text: yAxisLabel,
                color: chartTheme.textMuted,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 12, weight: '500' },
                padding: { top: 0, bottom: 10 },
              },
            },
          },
        },
      });

      // Store chart instance on canvas for cleanup
      canvas.chart = chart;

      // Hide loading state
      const loadingEl = document.getElementById(`chart-loading-${id}`);
      if (loadingEl) {
        loadingEl.style.display = 'none';
      }
    } catch (err) {
      if (isDev && typeof console !== 'undefined') {
        console.error('Failed to initialize chart:', err);
      }
      const container = document.getElementById(`chart-container-${id}`);
      const loadingEl = document.getElementById(`chart-loading-${id}`);

      if (loadingEl) {
        loadingEl.innerHTML = `
          <div class="flex flex-col items-center space-y-2 text-center p-4">
            <p class="text-sm font-medium text-red-500">Failed to load chart</p>
            <p class="text-xs text-[rgb(var(--color-text-muted))]">Data may be unavailable</p>
          </div>
        `;
      }

      if (container) {
        container.style.display = 'none';
      }
      // Also hide parent wrapper if it exists
      const wrapper = container?.parentElement;
      if (wrapper && wrapper.classList.contains('mb-6')) {
        wrapper.style.display = 'none';
      }
    }
  }

  // Error handler for chart initialization
  function handleChartError(error) {
    // Only log errors in development mode
    if (isDev && typeof console !== 'undefined' && console.error) {
      console.error('Failed to initialize chart:', error);
    }
  }

  // Initialize chart on load
  initChart().catch(handleChartError);

  // Re-initialize chart when theme changes
  window.addEventListener('themechange', () => {
    initChart().catch(handleChartError);
  });
</script>
